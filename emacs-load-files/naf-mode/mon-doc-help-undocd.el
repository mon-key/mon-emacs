;;; mon-doc-help-undocd.el --- { A one line description of: mon-doc-help-undocd. }
;; -*- mode: EMACS-LISP; no-byte-compile: t -*-

;;; ================================================================
;; Copyright © 2010 MON KEY. All rights reserved.
;;; ================================================================

;; FILENAME: mon-doc-help-undocd.el
;; AUTHOR: MON KEY
;; MAINTAINER: MON KEY
;; CREATED: 2010-09-08T14:30:24-04:00Z
;; VERSION: 1.0.0
;; COMPATIBILITY: Emacs23.*
;; KEYWORDS: 

;;; ================================================================

;;; COMMENTARY: 

;; =================================================================
;; DESCRIPTION:
;; mon-doc-help-undocd provides { some description here. }
;;
;; FUNCTIONS:►►►
;;
;; FUNCTIONS:◄◄◄
;;
;; MACROS:
;;
;; METHODS:
;;
;; CLASSES:
;;
;; CONSTANTS:
;;
;; FACES:
;;
;; VARIABLES:
;;
;; ALIASED/ADVISED/SUBST'D:
;;
;; DEPRECATED:
;;
;; RENAMED:
;;
;; MOVED:
;;
;; TODO:
;;
;; NOTES:
;;
;; SNIPPETS:
;;
;; REQUIRES:
;;
;; THIRD-PARTY-CODE:
;;
;; URL: http://www.emacswiki.org/emacs/mon-doc-help-undocd.el
;; FIRST-PUBLISHED:
;;
;; EMACSWIKI: { URL of an EmacsWiki describing mon-doc-help-undocd. }
;;
;; FILE-CREATED:
;; <Timestamp: #{2010-09-08T14:30:24-04:00Z}#{10363} - by MON KEY>
;;
;; =================================================================

;;; LICENSE:

;; =================================================================
;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;; =================================================================
;; Permission is granted to copy, distribute and/or modify this
;; document under the terms of the GNU Free Documentation License,
;; Version 1.3 or any later version published by the Free Software
;; Foundation; with no Invariant Sections, no Front-Cover Texts,
;; and no Back-Cover Texts. A copy of the license is included in
;; the section entitled ``GNU Free Documentation License''.
;; 
;; A copy of the license is also available from the Free Software
;; Foundation Web site at:
;; (URL `http://www.gnu.org/licenses/fdl-1.3.txt').
;;; ==============================
;; Copyright © 2010 MON KEY 
;;; ==============================

;;; CODE:


(eval-when-compile (require 'cl))

(unless (and (intern-soft "*IS-MON-OBARRAY*")
             (bound-and-true-p *IS-MON-OBARRAY*))
(setq *IS-MON-OBARRAY* (make-vector 17 nil)))


;;; ==============================


;; byte-compile-output-as-comment
;; Print Lisp object EXP in the output file, inside a comment,
;; and return the file position it will have.
;; If QUOTED is non-nil, print with quoting; otherwise, print without quoting.
;; Inserts EXP, making it a comment with #@LENGTH.
;; Quotes certain special characters as needed, get_doc_string in doc.c does the
;; unquoting.
;; Replace "\^A" with "\^A\^A"
;; Replace null chars "\000" with "\^A0".
;; Replace "\037" with "\^A_"
;; Insert "\037" at `point-max'.
;; Insert #@<OFFSET> at point e.g.:
;; (format "#@%d" (- (position-bytes (point-max)) (position-bytes (point))))
;; Save the file position of the object.

;; byte-compile-byte-code-maker
;; Given a function made by byte-compile-lambda, make a form which produces it.
;; When FUN is an atom return fun. Else, if fun is not a byte-code-object make
;; it so wth `make-byte-code'.

;; byte-compile-byte-code-unmake
;; Turn a function into an ordinary lambda.  Needed for v18 files.

;; byte-compile-lambda
;; Byte-compile a lambda-expression and return a valid function.
;; The value is usually a compiled function but may be the original
;; lambda-expression.
;; When ADD-LAMBDA is non-nil, the symbol `lambda' is added as head
;; of the list FUN and `byte-compile-set-symbol-position' is not called.
;; Use this feature to avoid calling `byte-compile-set-symbol-position'
;; for symbols generated by the byte compiler itself.

;; byte-compile-from-buffer
;; Among other things, when `old-style-backquotes' returns non-nil evaluates
;; `byte-compile-warn' with string:
;; "!! The file uses old-style backquotes !!
;;  This functionality has been obsolete for more than 10 years already and will
;;  be removed soon.  See (elisp)Backquote in the manual."

;; byte-compile-warn-about-unresolved-functions
;; If we have compiled any calls to functions which are not known to be
;; defined, issue a warning enumerating them.
;; `unresolved' in the list `byte-compile-warnings' disables this.
;; Issues the warning:
;; "The function <SYMBOL-NAME> might not be defined at runtime."
;; "The following functions might not be defined at runtime: <SYMBOL-NAME>*"
;; "The function <SYMBOL-NAME> is not known to be defined."
;; "The following functions are not known to be defined: <SYMBOL-NAME>*"
;;

;; byte-compile-file-form-eval
;; This handler is not necessary, but it makes the output from dont-compile
;; and similar macros cleaner.

;; byte-compile-file-form-with-no-warnings
;; cf byte-compile-file-form-progn.

;; print-gensym-alist <VARIABLE>
;; Used before print-circle existed.

;; bytecomp-outbuffer  <VARIABLE>
;; Dynamically bound in byte-compile-from-buffer.
;; NB also used in cl.el and cl-macs.el.

;;byte-compile-output-file-form
;; writes the given form to the output buffer, being careful of docstrings
;; in defun, defmacro, defvar, defvaralias, defconst, autoload and
;; custom-declare-variable because make-docfile is so amazingly stupid.
;; defalias calls are output directly by byte-compile-file-form-defmumble;
;; it does not pay to first build the defalias in defmumble and then parse
;; it here.

;; byte-compile-warn-about-unresolved-functions
;; If we have compiled any calls to functions which are not known to be
;; defined, issue a warning enumerating them.
;; `unresolved' in the list `byte-compile-warnings' disables this.

;; byte-compile-find-cl-functions
;; Can't just add this to cl-load-hook, because that runs just before
;; the forms from cl.el get added to load-history.
 
;; byte-compile-arglist-warn
;; Warn if the function or macro is being redefined with a different
;; number of arguments.

;; Warn if a custom definition fails to specify :group.

;; byte-compile-callargs-warn
;; Warn if the form is calling a function with the wrong number of arguments.

;; byte-compile-obsolete
;; "Used by make-obsolete."

;; byte-compile-fdefinition
;; If a function has an entry saying (FUNCTION . t).
;; that means we know it is defined but we don't know how.
;; If a function has an entry saying (FUNCTION . nil),
;; that means treat it as not defined.

;; byte-compile-inline-expand
;; This can be the 'byte-compile property of any symbol.

;; byte-optimize-form
;; This is the entrypoint to the lapcode optimizer pass1.

;; byte-optimize-lapcode
;; This is the entrypoint to the lapcode optimizer pass2.

;; byte-compile-form
;; This is the recursive entry point for compiling each subform of an
;; expression.
;; If for-effect is non-nil, byte-compile-form will output a byte-discard
;; before terminating (ie no value will be left on the stack).
;; A byte-compile handler may, when for-effect is non-nil, choose output code
;; which does not leave a value on the stack, and then set for-effect to nil
;; (to prevent byte-compile-form from outputting the byte-discard).
;; If a handler wants to call another handler, it should do so via
;; byte-compile-form, or take extreme care to handle for-effect correctly.
;; (Use byte-compile-form-do-effect to reset the for-effect flag too.)

;; byte-optimize-form-code-walker
;; For normal function calls, We can just mapcar the optimizer the cdr.  But
;; we need to have special knowledge of the syntax of the special forms
;; like let and defun (that's why they're special forms :-).  (Actually,
;; the important aspect is that they are subrs that don't evaluate all of
;; their args.)

;; byte-inline-lapcode
;; Splice the given lap code into the current instruction stream.
;; If it has any labels in it, you're responsible for making sure there
;; are no collisions, and that byte-compile-tag-number is reasonable
;; after this is spliced in.  The provided list is destroyed.
;; :NOTE Following additional comments discuss specific handling of the function
;; at car of form:
;; When car of form is `quote'
;; Map (quote nil) to nil to simplify optimizer logic.
;; Map quoted constants to nil if for-effect (just because).
;; When car of form is a `let' or `let*' recursively enter the optimizer for the
;; bindings and body of a let or let*.  This for depth-firstness: forms that are
;; more deeply nested are optimized first.
;; When car of form is `save-excursion', `save-restriction', or
;; `save-current-buffer' those subrs which have an implicit progn; it's not
;; quite good enough to treat these like normal function calls.  This can turn
;; \(save-excursion ...\) into \(save-excursion\) which will be optimized away in
;; the lap-optimize pass by `byte-optimize-body'ing form's cdr.
;; When car of form is `with-output-to-temp-buffer' this is just like the above
;; except for the first argument which is `byte-optimize-form'd 
;; When car of form is an `and' or an `or' take forms off the back until we
;; can't any more.  In the future it could conceivably be a problem that the
;; subexpressions of these forms are optimized in the reverse order, but it's ok
;; for now. Remember, and/or are control structures.
;; When car of form is `defun', `defmacro', `function', `condition-case', or
;; `save-window-excursion' these forms are compiled as constants or by breaking
;; out all the subexpressions and compiling them separately.
;; When car of form is `unwind-protect' the "protected" part of an
;; unwind-protect is compiled (and thus optimized) as a top-level form, so don't
;; do it here.  But the non-protected part has the same for-effect status as the
;; unwind-protect itself.  (The protected part is always for effect, but that
;; isn't handled properly yet.)
;; When car of form is `catch' the body of a catch is compiled (and thus
;; optimized) as a top-level form, so don't do it here.  The tag is never
;; for-effect.  The body should have the same for-effect status as the catch
;; form itself, but that isn't handled properly yet.
;; When car of form is `ignore' don't treat the args to `ignore' as being
;; computed for effect.  We want to avoid the warnings that might occur if they
;; were treated that way.  However, don't actually bother calling `ignore'.
;; when optimization is on and form is not a cl-compiler-macro and its
;; macroexpansion through `byte-compile-macro-environment' indicates further
;; expansion is required form is `byte-optimize-form'd. This is the only place
;; that macros are expanded.  If optimization is off, then macroexpansion
;; happens in byte-compile-form.  Otherwise, the macros are already expanded by
;; the time that is reached.
;; When car of form a cl-compiler-macro support compiler macros as in cl.el with
;; `byte-optimize-form' if form does not `compiler-macroexpand' to itself.
;; When car of form does not satisfy any of the conditionals no args can be
;; considered to be for-effect, even if the called function is for-effect,
;; because we don't know anything about that function.

;; byte-optimize-form
;; First, optimize all sub-forms of form with `byte-optimize-form-code-walker'.
;; After optimizing all subforms, optimize this form until it doesn't
;; optimize any further.  This means that some forms will be passed through
;; the optimizer many times, but that's necessary to make the for-effect
;; processing do as much as possible.

;; byte-optimize-body
;; Optimize the cdr of a progn or implicit progn; all forms is a list of
;; forms, all but the last of which are optimized with the assumption that
;; they are being called for effect.  the last is for-effect as well if
;; all-for-effect is true.  returns a new list of forms.

;; byte-optimize-associative-math
;; If the function is being called with constant numeric args,
;; evaluate as much as possible at compile-time.  This optimizer
;; assumes that the function is associative, like + or *.

;; byte-optimize-nonassociative-math
;; If the function is being called with constant numeric args,
;; evaluate as much as possible at compile-time.  This optimizer
;; assumes that the function satisfies
;;   (op x1 x2 ... xn) == (op ...(op (op x1 x2) x3) ...xn)
;; like - and /.

;; byte-optimize-delay-constants-math
;; Collect all the constants from FORM, after the STARTth arg,
;; and apply FUN to them to make one argument at the end.
;; For functions that can handle floats, that optimization
;; can be incorrect because reordering can cause an overflow
;; that would otherwise be avoided by encountering an arg that is a float.
;; We avoid this problem by (1) not moving float constants and
;; (2) not moving anything if it would cause an overflow.
;; Merge all FORM's constants from number START, call FUN on them
;; and put the result at the end.

;; byte-optimize-quote
;; It may sometimes be necessary to reduce (quote 5) to 5,
;; so arithmetic optimizers recognize the numeric constant.

;; byte-optimize-and
;; Simplify if less than 2 args.
;; if there is a literal nil in the args to `and', throw it and following
;; forms away, and surround the `and' with (progn ... nil).

;; byte-optimize-or
;; Throw away nil's, and simplify if less than 2 args.
;; If there is a literal non-nil constant in the args to `or', throw away all
;; following forms.

;; byte-optimize-cond
;; if any clauses have a literal nil as their test, throw them away.
;; if any clause has a literal non-nil constant as its test, throw
;; away all following clauses.

;; byte-optimize-if
;; \(if \(progn <insts> <test>\) <rest>\) ==> \(progn <insts> \(if <test> <rest>\)\)
;; \(if <true-constant> <then> <else...>\) ==> <then>
;; \(if <false-constant> <then> <else...>\) ==> \(progn <else...>\)
;; \(if <test> nil <else...>\) ==> \(if \(not <test>\) \(progn <else...>\)\)
;; \(if <test> <then> nil\) ==> \(if <test> <then>\)

;; byte-optimize-funcall
;; \(funcall \(lambda ...\) ...\) ==> \(\(lambda ...\) ...\)
;; \(funcall foo ...\) ==> \(foo ...\)

;; byte-optimize-apply
;; If the last arg is a literal constant, turn this into a funcall.
;; The funcall optimizer can then transform (funcall 'foo ...) -> (foo ...).

;; byte-optimize-featurep
;; Emacs-21's byte-code doesn't run under XEmacs or SXEmacs anyway, so we
;; can safely optimize away this test.

;; byte-compile-splice-in-already-compiled-code
;; Form is \(byte-code \"...\" [...] n\)

;; disassemble-offset
;; This function extracts the bitfields from variable-length opcodes.
;; Originally defined in :FILE disass.el \(which no longer uses it\).  
;; Fetch and return the offset for the current opcode.  Return nil if this
;; opcode has no offset OP, PTR and BYTES are used and set dynamically.

;; byte-decompile-bytecode
;; This de-compiler is used for inline expansion of compiled functions, and by
;; the disassembler.  This list contains numbers, which are pc values, before
;; each instruction.

;; byte-decompile-bytecode-1
;; As byte-decompile-bytecode, but updates
;; byte-compile-{constants, variables, tag-number}.
;; If MAKE-SPLICEABLE is true, then `return' opcodes are replaced
;; with `goto's destined for the end of the code.
;; That is for use by the compiler.
;; If MAKE-SPLICEABLE is nil, we are being called for the disassembler.
;; In that case, we put a pc value into the list
;; before each insn \(or its label\).

;; byte-after-unbind-ops
;; How about other side-effect-free-ops?  Is it safe to move an
;; error invocation (such as from nth) out of an unwind-protect?
;; No, it is not, because the unwind-protect forms can alter
;; the inside of the object to which nth would apply.
;; For the same reason, byte-equal was deleted from this list.

;;;;;;;;;; :FILE lisp/emacs-lisp/edebug.el ;;;;;;;;;;;;;;;;;;;;;;;;;

;; edebug-match-&rest
;; Repeatedly use SPECS until failure.

;; edebug-match-&or
;; Keep matching until one spec succeeds, and return its results.
;; If none match, fail.
;; This needs to be optimized since most specs spend time here.

;; edebug-match-&optional
;; Keep matching until one spec fails.

;; edebug-match-place
;; Currently identical to edebug-match-form.
;; This is for common lisp setf-style place arguments.

;; edebug-match-symbol
;; Match a symbol spec.

;; edebug-match-specs
;; Append results of matching the list of specs.
;; The first spec is handled and the remainder-handler handles the rest.

;; edebug-match-one-spec
;; Match one spec, which is not a keyword &-spec.

;; edebug-match
;; Top level spec matching function.
;; Used also at each lower level of specs.

;; edebug-no-match
;; Throw a no-match, or signal an error immediately if gate is active.
;; Remember this point in case we need to report this error.
;; This throws to no-match, if there are higher alternatives.
;; Otherwise it signals an error.  The place of the error is found
;; with the two before- and after-offset functions.

;; edebug-max-depth <CONSTANT>
;; maximum number of matching recursions.

;; edebug-matching-depth <VARIABLE>
;; initial value is 0.

;; edebug-list-form
;; Return an instrumented form built from the list form.
;; The after offset will be left in the cursor after processing the form.

;; edebug-list-form-args
;; Process the arguments of a list form given that head of form is a symbol.
;; Helper for edebug-list-form

;; edebug-form
;; Return the instrumented form for the following form.
;; Add the point offsets to the edebug-offset-list for the form.

;; edebug-clear-coverage
;; Create initial coverage vector.
;; Only need one per expression, but it is simpler to use stop points.

;; edebug-clear-frequency-count
;; Create initial frequency count vector.
;; For each stop point, the counter is incremented each time it is visited.

;; edebug-make-form-wrapper
;; Wrap a form, usually a defining form, but any evaluated one.
;; If speclist is non-nil, this is being called by edebug-defining-form.
;; Otherwise it is being called from edebug-read-and-maybe-wrap-form1.
;; This is a hack, but I havent figured out a simpler way yet.

;; edebug-defining-form
;; Process the defining form, starting outside the form.
;; The speclist is a generated list spec that looks like:
;;   (("def-symbol" defining-form-spec-sans-&define))
;; Skip the first offset.

;; edebug-make-after-form
;; Like edebug-make-before-and-after-form, but only after.

;; edebug-make-before-and-after-form
;; Return the edebug form for the current function at offset BEFORE-INDEX
;; given FORM.  Looks like:
;; (edebug-after (edebug-before BEFORE-INDEX) AFTER-INDEX FORM)
;; Also increment the offset index for subsequent use.


;; edebug-inc-offset
;; modifies edebug-offset-index and edebug-offset-list
;; accesses edebug-func-marc and buffer point

;; edebug-offset-list <VARIABLE>
;; the list of offset positions.

;; edebug-offset-index <VARIABLE>
;; the next available offset index.

;; edebug-form-begin-marker <VARIABLE>
;; the mark for def being instrumented

;; edebug-make-enter-wrapper
;; Generate the enter wrapper for some forms of a definition.
;; This is not to be used for the body of other forms, e.g. `while',
;; since it wraps the list of forms with a call to `edebug-enter'.
;; Uses the dynamically bound vars edebug-def-name and edebug-def-args.
;; Do this after parsing since that may find a name.

;; edebug-interactive-p-name
;; Return a unique symbol for the variable used to store the
;; status of interactive-p for this function.

;; edebug-inside-func <VARIABLE>
;; whether code is inside function context.
;; Currently def-form sets this to nil; def-body sets it to t.

;; edebug-def-interactive <VARIABLE>
;; is it an emacs interactive function?

;; edebug-def-args <VARIABLE>
;; args of defining form.

;; edebug-read-and-maybe-wrap-form
;; Read a form and wrap it with edebug calls, if the conditions are right.
;; Here we just catch any no-match not caught below and signal an error.
;; Run the setup hook.
;; If it gets an error, make it nil.
;;
;; The Parser
;;
;; The top level function for parsing forms is
;; edebug-read-and-maybe-wrap-form; it calls all the rest.  It checks the
;; syntax a bit and leaves point at any error it finds, but otherwise
;; should appear to work like eval-defun.
;;
;; The basic plan is to surround each expression with a call to
;; the edebug debugger together with indexes into a table of positions of
;; all expressions.  Thus an expression "exp" becomes:
;;
;; \(edebug-after \(edebug-before 1\) 2 exp\)
;;
;; When this is evaluated, first point is moved to the beginning of
;; exp at offset 1 of the current function.  The expression is
;; evaluated, which may cause more edebug calls, and then point is
;; moved to offset 2 after the end of exp.
;;
;; The highest level expressions of the function are wrapped in a call to
;; edebug-enter, which supplies the function name and the actual
;; arguments to the function.  See functions edebug-enter, edebug-before,
;; and edebug-after for more details.
;;
;; Dynamically bound vars, left unbound, but globally declared.
;; This is to quiet the byte compiler.
;;
;; Window data of the highest definition being wrapped.
;; This data is shared by all embedded definitions.

;; edebug-old-def-name <VARIABLE>
;; previous name of containing definition.

;; edebug-def-name <VARIABLE>
;; name of definition, used by interactive-form

;; edebug-gate <VARIABLE>
;; whether no-match forces an error.

;; edebug-after-offset
;; Return the after offset of the cursor object.

;; edebug-before-offset
;; Return the before offset of the cursor.  If there is nothing left in the
;; offsets, return one less than the offset itself, which is the after offset
;; for a list.

;; edebug-move-cursor
;; Advance and return the cursor to the next element and offset.
;; throw no-match if empty before moving.
;; This is a violation of the cursor encapsulation, but
;; there is plenty of that going on while matching.
;; The following test should always fail.

;; edebug-top-offset
;; Return the top offset pair corresponding to the top element.

;; edebug-top-element
;; Return the top element at the CURSOR.
;; Assumes not empty.

;; edebug-empty-cursor
;; Return non-nil if CURSOR is empty - meaning no more elements.

;; edebug-copy-cursor
;; Copy the cursor using the same object and offsets.

;; edebug-set-cursor
;; Set the CURSOR's EXPRESSIONS and OFFSETS to the given.
;; Return the cursor.

;; edebug-new-cursor
;; Return a new cursor for EXPRESSIONS with OFFSETS.

;; edebug-read-function
;; Turn #'thing into (function thing)

;; edebug-read-comma
;; Turn ,thing into (\, thing).  Handle ,@ and ,. also.

;; edebug-read-backquote
;; Turn `thing into (\` thing)

;; edebug-read-quote
;; Turn 'thing into (quote thing)

;; edebug-ignore-offset
;; Ignore the last created offset pair.

;; edebug-ignore-offset
;; Ignore the last created offset pair.

;; edebug-store-after-offset
;; Finalize the current offset struct by reversing it and
;; store POINT as the after offset.

;; edebug-store-before-offset
;; Add a new offset pair with POINT as the before offset.

;; edebug-initialize-offsets
;; Reinitialize offset recording.

;; edebug-offsets-stack <VARIABLE>
;; Stack of offset structures in reverse order of the nesting.
;; This is used to get back to previous levels.

;; edebug-current-offset <VARIABLE>
;; Top of the stack, for convenience.

;; edebug-read-dotted-list <VARIABLE>
;; Store whether we just read a list with a dotted form that
;; is itself a list.  This structure will be condensed, so the offsets
;; must also be condensed.

;; edebug-offsets <VARIABLE>
;; Define a structure to represent offset positions of expressions.
;; Each offset structure looks like: (before . after) for constituents,
;; or for structures that have elements: (before <subexpressions> . after)
;; where the <subexpressions> are the offset structures for subexpressions
;; including the head of a list.

;; edebug-read-sexp
;; Read one sexp from the current buffer starting at point.
;; Leave point immediately after it.  A sexp can be a list or atom.
;; An atom is a symbol (or number), character, string, or vector.
;; This works for reading anything legitimate, but it
;; is gummed up by parser inconsistencies (bugs?)
;; :NOTE Mostly obsolete reader; still used in one case.

;; edebug-skip-whitespace
;; Leave point before the next token, skipping white space and comments.

;; edebug-next-token-class
;; Move to the next token and return its class.  We only care about
;; lparen, rparen, dot, quote, backquote, comma, string, char, vector,
;; or symbol.

;; edebug-read-syntax-table <CONSTANT>
;; Lookup table for significant characters indicating the class of the
;; token that follows.  This is not a \"real\" syntax table.

;; edebug-syntax-error
;; Signal invalid-read-syntax with ARGS.

;; edebug-clear-form-data-entry
;; If non-nil, clear ENTRY out of the form data.
;; Maybe clear the markers and delete the symbol's edebug property?

;; edebug-make-top-form-data-entry
;; Make NEW-ENTRY the first element in the `edebug-form-data' list.

;; edebug-form-data-symbol
;; Return the edebug data symbol of the form where point is in.
;; If point is not inside a edebuggable form, cause error.

;; edebug-get-form-data-entry
;; Find the edebug form data entry which is closest to PNT.
;; If END-POINT is supplied, match must be exact.
;; Return `nil' if none found.

;; edebug-form-data
;; A list of entries associating symbols with buffer regions.
;; The internal data that is needed for edebugging is kept in the
;; buffer-local variable `edebug-form-data'.
;;
;; Each entry has the form:
;;
;;  @code{(@var{symbol} @var{begin-marker} @var{end-marker}).  
;; The markers are at the beginning and end of an entry level form and
;; @var{symbol} is a symbol that holds all edebug related information for the
;; form on its property list.
;;
;; In the future, the symbol will be irrelevant and edebug data will
;; be stored in the definitions themselves rather than in the property
;; list of a symbol.

;; edebug-set-windows
;; Set either a full window configuration or some window information.

;; edebug-current-windows
;; Get either a full window configuration or some window information.

;; edebug-set-buffer-points
;; Restore the buffer-points created by edebug-get-displayed-buffer-points.

;; edebug-get-displayed-buffer-points
;; Return a list of buffer point pairs, for all displayed buffers.

;; edebug-pop-to-buffer
;; Like pop-to-buffer, but select window where BUFFER was last shown.
;; Select WINDOW if it is provided and still exists.  Otherwise,
;; if buffer is currently shown in several windows, choose one.
;; Otherwise, find a new window, possibly splitting one.

;; edebug-sort-alist
;; Return the ALIST sorted with comparison function FUNCTION.
;; This uses 'sort so the sorting is destructive.

;; edebug-last-sexp
;; Return the last sexp before point in current buffer.
;; Assumes Emacs Lisp syntax is active.

;;;;;;;;;;;;;;;;;;; :FILE lisp/emacs-lisp/elp.el ;;;;;;;;;;;;;;;;;;;;

;; elp-output-insert-symname
;; Insert SYMNAME with text properties.

;; elp-output-result
;; output the RESULTVEC into the results buffer. RESULTVEC is a 4 or
;; more element vector where aref 0 is the call count, aref 1 is the
;; total time spent in the function, aref 2 is the average time
;; spent in the function, and aref 3 is the symbol's string
;; name. All other elements in the vector are ignored.

;; elp-pack-number
;; pack the NUMBER string into WIDTH characters, watching out for
;; very small or large numbers

;; elp-sort-by-average-time
;; sort by highest average time spent in function. See `sort'.

;; elp-sort-by-total-time
;; sort by highest total time spent in function. See `sort'.

;; elp-sort-by-call-count 
;; sort by highest call count.  See `sort'.

;; elp-instrument-function
;; Instrument FUNSYM for profiling.
;; FUNSYM must be a symbol of a defined function.
;; Before instrumenting restore the function to a non profiled state.
;; This is necessary to avoid infinite recursion of already instrumented
;; functions \(i.e. `elp-wrapper' calling elp-wrapper ad infinitum\).
;; It is better to simply restore the function than to throw an error.  this
;; will work properly in the face of `eval-defun' because if the function was
;; redefined, only the timer info will be nil'd out since `elp-restore-function'
;; is smart enough not to trash the new definition.
;; Signal an error if function is an autoload function.
;; :NOTE Comment indicates that: 
;; At some point it might be better to load the autoloaded
;; function instead of throwing an error.  If we do this, then we
;; probably want elp-instrument-package to be updated with the
;; newly loaded list of functions.  I'm not sure it's smart to do
;; the autoload here, since that could have side effects, and
;; elp-instrument-function is similar (in my mind) to defun-ish
;; type functionality \(i.e. it shouldn't execute the function\).
;; to record profiling times, we set the symbol's function
;; definition so that it runs the elp-wrapper function with the
;; function symbol as an argument.  We place the old function
;; definition on the info vector.
;;
;; The info vector data structure is a 3 element vector.  The 0th
;; element is the call-count, i.e. the total number of times this
;; function has been entered.  This value is bumped up on entry to
;; the function so that non-local exists are still recorded. TBD:
;; I haven't tested non-local exits at all, so no guarantees.
;;
;; The 1st element is the total amount of time in usecs that have
;; been spent inside this function.  This number is added to on
;; function exit.
;;
;; The 2nd element is the old function definition list.  This gets
;; funcall'd in between start/end time retrievals. I believe that
;; this lets us profile even byte-compiled functions.
;;
;; Put info vector `elp-timer-info-property` property on FUNSYM's property list.
;; Set the symbol's new profiling function definition to run
;; elp-wrapper. 
;; Put ad-advice-info property on FUNSYM's property list. to
;; temporarily guard advice from advisisng FUNSYM.
;; Add FUNSYM to the instrumentation list `elp-all-instrumented-list'.

;; edebug-form-data <VARIABLE>
;; A list of entries associating symbols with buffer regions.
;; This is an automatic buffer local variable.  Each entry looks like:
;; @code{(@var{symbol} @var{begin-marker} @var{end-marker}).  The markers
;; are at the beginning and end of an entry level form and @var{symbol} is
;; a symbol that holds all edebug related information for the form on its
;; property list.

;; In the future, the symbol will be irrelevant and edebug data will
;; be stored in the definitions themselves rather than in the property
;; list of a symbol.

;;;;;;;;;;;;;;; :FILE lisp/emacs-lisp/cl-macs.el ;;;;;;;;;;;;;;;;;;;;
;; cl-const-expr-p
;; Check if constant (i.e., no side effects or dependencies).

;; cl-safe-expr-p
;; Check if no side effects.

;; cl-simple-expr-p
;; Check if no side effects, and executes quickly.

;; cl-expr-contains
;; Count number of times X refers to Y.  Return nil for 0 times.

;; cl-simple-funcs
;; Called by cl-* predicates for analyzing Lisp forms. 
;; `cl-simple-expr-p' `cl-simple-exprs-p' `cl-safe-expr-p' `cl-const-expr-p'
;; `cl-const-exprs-p'
;; Which in turn are used by various macro expanders to optimize the results in
;; certain common cases.

;; cl-safe-funcs
;; Called by cl-* predicates for analyzing Lisp forms. 
;; Which in turn are used by various macro expanders to optimize the results in
;; certain common cases.
;;
;;;;;;;;;;;;;;; :FILE lisp/emacs-lisp/newcomment.el ;;;;;;;;;;;;;;;;;;;;

;; comment-add
;; Compute the number of extra comment starter characters
;; (extra semicolons in Lisp mode, extra stars in C mode, etc.)
;; If ARG is non-nil, just follow ARG.
;; If the comment-starter is multi-char, just follow ARG.
;; Otherwise obey comment-add, and double it if EXTRA is non-nil.
;;
;;;;;;;;;;;;;;; :FILE lisp/emacs-lisp/ido.el ;;;;;;;;;;;;;;;;;;;;

;; ido-all-completions
;; Return unsorted list of all competions.

;; ido-name
;; Return file name for current item, whether in a normal list
;; or a merged work directory list.

;; ido-file-lessp
;; Simple compare two file names.

;; ido-file-extension-lessp
;; Compare file names according to ido-file-extensions-order list.

;; ido-sort-merged-list
;; Input is list of ("file" . "dir") cons cells.
;; Output is sorted list of ("file "dir" ...) lists

;; ido-wide-find-dirs-or-files
;; As `ido-run-find-command', but returns a list of cons pairs ("file" . "dir")

;; ido-flatten-merged-list
;; Create a list of directory names based on a merged directory list.

;; ido-make-buffer-list-1
;; Return list of non-ignored buffer names

;; ido-make-choice-list
;; Return the current list of choices.
;; If DEFAULT is non-nil, and corresponds to an element of choices,
;; it is put to the start of the list.

;; ido-make-buffer-list
;; Return the current list of buffers.
;; Currently visible buffers are put at the end of the list.
;; The hook `ido-make-buffer-list-hook' is run after the list has been
;; created to allow the user to further modify the order of the buffer names
;; in this list.  If DEFAULT is non-nil, and corresponds to an existing buffer,
;; it is put to the start of the list.

;;;;;;;;;;;;;;; :FILE lisp/minibuffer.el ;;;;;;;;;;;;;;;;
;;

;; completion-annotate-function <VARIABLE>
;; Note: there's a lot of scope as for when to add annotations and
;; what annotations to add.  E.g. completing-help.el allowed adding
;; the first line of docstrings to M-x completion.  But there's
;; a tension, since such annotations, while useful at times, can
;; actually drown the useful information.
;; So completion-annotate-function should be used parsimoniously, or
;; else only used upon a user's request (e.g. we could add a command
;; to completion-list-mode to add annotations to the current
;; completions).

;;;;;;;;;;;;;;; :FILE lisp/simple.el ;;;;;;;;;;;;;;;;;;;;
;;

;; completion-setup-function
;; This function goes in completion-setup-hook, so that it is called
;; after the text of the completion list buffer is written.

;;
;;;;;;;;;;;;;;; :FILE lisp/apropos.el ;;;;;;;;;;;;;;;;;;;;

;; apropos-documentation-check-doc-file
;; Finds all documentation related to APROPOS-REGEXP in internal-doc-file-name.

;; apropos-symbols-internal
;; Filter out entries that are marked as apropos-inhibit.

;;;;;;;;;;;; :FILE lisp/dired-aux.el ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; dired-add-entry
;; Add a new entry for FILENAME, optionally marking it
;; with MARKER-CHAR (a character, else dired-marker-char is used).
;; Note that this adds the entry `out of order' if files sorted by
;; time, etc.
;; At least this version inserts in the right subdirectory (if present).
;; And it skips "." or ".." (see `dired-trivial-filenames').
;; Hidden subdirs are exposed if a file is added there.

;; dired-after-subdir-garbage
;; Return psn of first file line of DIR, skipping header and total
;; or wildcard lines.
;; :NOTE Never moves into the next subdir. DIR is assumed to be unhidden.

;; dired-relist-entry
;; Relist the line for FILE, or just add it if it did not exist.
;; FILE must be an absolute file name.

;; dired-overwrite-confirmed <VARIABLE>
;; This is a fluid var used in dired-handle-overwrite.  It should be
;; let-bound whenever dired-copy-file etc are called.  See
;; dired-create-files for an example.

;; dired-handle-overwrite
;; Save old version of file TO that is to be overwritten.

;; dired-rename-subdir-1
;; Rename DIR to TO in headerlines and dired-subdir-alist, if DIR or
;; one of its subdirectories is expanded in this buffer.

;; dired-rename-subdir-2
;; Update the headerline and dired-subdir-alist element, as well as
;; dired-switches-alist element, of directory described by
;; alist-element ELT to reflect the moving of DIR to TO.  Thus, ELT
;; describes either DIR itself or a subdir of DIR.

;; dired-create-files
;; Create a new file for each from a list of existing files.  The user
;; is queried, dired buffers are updated, and at the end a success or
;; failure message is displayed
;;
;; FILE-CREATOR must accept three args: oldfile newfile ok-if-already-exists
;;
;; It is called for each file and must create newfile, the entry of
;; which will be added.  The user will be queried if the file already
;; exists.  If oldfile is removed by FILE-CREATOR (i.e, it is a
;; rename), it is FILE-CREATOR's responsibility to update dired
;; buffers.  FILE-CREATOR must abort by signaling a file-error if it
;; could not create newfile.  The error is caught and logged.
;;
;; OPERATION (a capitalized string, e.g. `Copy') describes the
;; operation performed.  It is used for error logging.
;;
;; FN-LIST is the list of files to copy (full absolute file names).
;;
;; NAME-CONSTRUCTOR returns a newfile for every oldfile, or nil to
;; skip.  If it skips files for other reasons than a direct user
;; query, it is supposed to tell why (using dired-log).
;;
;; Optional MARKER-CHAR is a character with which to mark every
;; newfile's entry, or t to use the current marker character if the
;; oldfile was marked.
;; :NOTE This function is basis for half a dozen variations on cp/mv/ln/ln -s.

;; dired-mark-read-file-name
;; Read arguments for a marked-files command that wants a file name,
;; perhaps popping up the list of marked files.
;; ARG is the prefix arg and indicates whether the files came from
;; marks (ARG=nil) or a repeat factor (integerp ARG).
;; If the current file was used, the list has but one element and ARG
;; does not matter. (It is non-nil, non-integer in that case, namely '(4)).
;; DEFAULT is the default value to return if the user just hits RET;
;; if it is omitted or nil, then the name of the directory is used.

;; dired-dwim-target-directory
;; Try to guess which target directory the user may want.
;; If there is a dired buffer displayed in one of the next windows,
;; use its current subdir, else use current subdir of this dired buffer.

;; dired-dwim-target-defaults
;; Return a list of default values for file-reading functions in Dired.
;; This list may contain directories from Dired buffers in other windows.
;; `fn-list' is a list of file names used to build a list of defaults.
;; When nil or more than one element, a list of defaults will
;; contain only directory names.  `target-dir' is a directory name
;; to exclude from the returned list, for the case when this
;; directory name is already presented in initial input.
;; For Dired operations that support `dired-dwim-target',
;; the argument `target-dir' should have the value returned
;; from `dired-dwim-target-directory'.

;; dired-into-dir-with-symlinks
;; This may not always be what you want, especially if target is your
;; home directory and it happens to be a symbolic link, as is often the
;; case with NFS and automounters.  Or if you want to make symlinks
;; into directories that themselves are only symlinks, also quite
;; common.
;;
;; So we don't use this function as value for HOW-TO in
;; dired-do-symlink, which has the minor disadvantage of
;; making links *into* a symlinked-dir, when you really wanted to
;; *overwrite* that symlink.  In that (rare, I guess) case, you'll
;; just have to remove that symlink by hand before making your marked
;; symlinks.

;; dired-do-create-files-regexp
;; Create a new file for each marked file using regexps.
;; FILE-CREATOR and OPERATION as in dired-create-files.
;; ARG as in dired-get-marked-files.
;; Matches each marked file against REGEXP and constructs the new
;;   filename from NEWNAME (like in function replace-match).
;; Optional arg WHOLE-NAME means match/replace the whole file name
;;   instead of only the non-directory part of the file.
;; Optional arg MARKER-CHAR as in dired-create-files.

;; dired-mark-read-regexp
;; Prompt user about performing OPERATION.
;; Read and return list of: regexp newname arg whole-name.

;; dired-update-file-line
;; Delete the current line, and insert an entry for FILE.
;; If FILE is nil, then just delete the current line.
;; Keeps any marks that may be present in column one (doing this
;; here is faster than with dired-add-entry's optional arg).
;; Does not update other dired buffers.  Use dired-relist-entry for that.

;; dired-create-files-non-directory
;; Perform FILE-CREATOR on the non-directory part of marked files
;; using function BASENAME-CONSTRUCTOR, with query for each file.
;; OPERATION like in dired-create-files, ARG as in dired-get-marked-files.

;; dired-insert-subdir-validate
;; Check that it is valid to insert DIRNAME with SWITCHES.
;; Signal an error if invalid \(e.g. user typed `i' on `..'\).

;; dired-alist-add
;; Add new DIR at NEW-MARKER.  Sort alist.

;; dired-alist-sort
;; Keep the alist sorted on buffer position.

;; dired-insert-subdir-newpos
;; Find psn for new subdir, according to tree order.

;; dired-insert-subdir-del
;; Erase an already present subdir (given by ELEMENT) from buffer.
;; Move to that buffer position.  Return a mark-alist.

;; dired-insert-subdir-doinsert
;; Insert ls output after point.
;; Return the boundary of the inserted text \(as list of BEG and END\).

;; dired-insert-subdir-doupdate
;; Point is at the correct subdir alist position for ELT,
;; BEG-END is the subdir-region \(as list of begin and end\).

;; dired-tree-lessp
;; Lexicographic order on file name components, like `ls -lR':
;; DIR1 < DIR2 if DIR1 comes *before* DIR2 in an `ls -lR' listing,
;; i.e., if DIR1 is a (grand)parent dir of DIR2,
;; or DIR1 and DIR2 are in the same parentdir and their last
;; components are `string-lessp'.
;; Thus \(\"/usr/\" \"/usr/bin\"\) and \(\"/usr/a/\" \"/usr/b/\"\) are
;; tree-lessp.  `string-lessp' could arguably be replaced by
;; `file-newer-than-file-p' if `dired-actual-switches' contained `t'.


;; dired-load
;; Return nil for success, offending file name else.

;; dired-byte-compile
;; Return nil for success, offending file name else.

;; dired-map-over-marks-check
;; Map FUN over marked files \(with second ARG like in dired-map-over-marks\)
;; and display failures.
;;
;; FUN takes zero args.  It returns non-nil (the offending object, e.g.
;; the short form of the filename) for a failure and probably logs a
;; detailed error explanation using function `dired-log'.
;;
;; OP-SYMBOL is a symbol describing the operation performed \(e.g.
;; `compress'\).  It is used with `dired-mark-pop-up' to prompt the user
;; (e.g. with `Compress * [2 files]? ') and to display errors (e.g.
;; `Failed to compress 1 of 2 files - type W to see why \(\"foo\"\)'\)
;;
;; SHOW-PROGRESS if non-nil means redisplay dired after each file.

;; dired-mark-confirm
;; Request confirmation from the user that the operation described
;; by OP-SYMBOL is to be performed on the marked files.
;; Confirmation consists in a y-or-n question with a file list
;; pop-up unless OP-SYMBOL is a member of `dired-no-confirm'.
;; The files used are determined by ARG (as in dired-get-marked-files).

;; dired-compress-file
;; Compress or uncompress FILE.
;; Return the name of the compressed or uncompressed file.
;; Return nil if no change in files.

;; dired-compress
;; Compress or uncompress the current file.
;; Return nil for success, offending filename else.

;; dired-check-process
;; Display MSG while running PROGRAM, and check for output.
;; Remaining arguments are strings passed as command arguments to PROGRAM.
;; On error, insert output in a log buffer and return the offending ARGUMENTS or
;; PROGRAM.
;; Caller can cons up a list of failed args.
;; Else returns nil for success.

;; dired-shell-stuff-it
;; Make up a shell command line from COMMAND and FILE-LIST.
;; If ON-EACH is t, COMMAND should be applied to each file, else
;; simply concat all files and apply COMMAND to this.
;; FILE-LIST's elements will be quoted for the shell.
;; Might be redefined for smarter things and could then use RAW-ARG
;; \(coming from interactive P and currently ignored\) to decide what to do.
;; Smart would be a way to access basename or extension of file names.

;; dired-map-dired-file-lines
;; Perform FUN with point at the end of each non-directory line.
;; FUN takes one argument, the absolute filename.

;; dired-mark-read-string
;; PROMPT for a string, with INITIAL input and DEFAULT value.
;; Other args are used to give user feedback and pop-up:
;; OP-SYMBOL of command, prefix ARG, marked FILES.
;; Read arguments for a marked-files command that wants a string
;; that is not a file name,
;; perhaps popping up the list of marked files.
;; ARG is the prefix arg and indicates whether the files came from
;; marks (ARG=nil) or a repeat factor (integerp ARG).
;; If the current file was used, the list has but one element and ARG
;; does not matter. (It is non-nil, non-integer in that case, namely '(4)).

;; dired-bunch-files
;; Process all the files in FILES in batches of a convenient size,
;; by means of (FUNCALL FUNCTION ARGS... SOME-FILES...).
;; Batches are chosen to need less than MAX chars for the file names,
;; allowing 3 extra characters of separator per file name.

;; dired-do-chxxx
;; Change file attributes (mode, group, owner, timestamp) of marked files and
;; refresh their file lines.
;; ATTRIBUTE-NAME is a string describing the attribute to the user.
;; PROGRAM is the program used to change the attribute.
;; OP-SYMBOL is the type of operation (for use in dired-mark-pop-up).
;; ARG describes which files to use, as in dired-get-marked-files.

;;;;;;;;;;; lisp/net/browse-url.el ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; browse-url-delete-temp-file
;; Delete browse-url-temp-file-name from the file system
;; If optional arg TEMP-FILE-NAME is non-nil, delete it instead. 

;; browse-url-maybe-new-window
;; called-interactive-p needs to be called at a function's top-level, hence
;; this macro.  We use that rather than interactive-p because
;; use in a keyboard macro should not change this behavior.

;; browse-url-maybe-new-window
;; called-interactive-p needs to be called at a function's top-level, hence
;; this macro.  We use that rather than interactive-p because
;; use in a keyboard macro should not change this behavior.

;;;;;;;;;;; lisp/info.el ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Info-insert-dir
;; Construct the Info directory node by merging the files named `dir'
;; from various directories.  Set the *info* buffer's
;; default-directory to the first directory we actually get any text
;; from.

;; Info-dir-file-attributes <VARIABLE>
;; Record the file attributes of all the files from which we
;; constructed Info-dir-contents

;; Info-dir-contents-directory
;; Cache for the directory we decided to use for the default-directory
;; of the merged dir text.

;; Info-dir-contents
;; Cache the contents of the (virtual) dir file, once we have merged
;; it for the first time, so we can save time subsequently.

;; info-insert-file-contents-1
;; Concatenate SUFFIX onto FILENAME.  SUFFIX should start with a dot.
;; First, on MS-DOS with no long file names support, delete some of
;; the extension in FILENAME to make room.

;; Info-node-at-bob-matching
;; See if the accessible portion of the buffer begins with a node
;; delimiter, and the node header line which follows matches REGEXP.
;; Typically, this test will be followed by a loop that examines the
;; rest of the buffer with (search-forward "\n\^_"), and it's a pity
;; to have the overhead of this special test inside the loop.
;;
;; This function changes match-data, but supposedly the caller might
;; want to use the results of re-search-backward.
;;
;; The return value is the value of point at the beginning of matching
;; REGEXP, if the function succeeds, nil otherwise.

;; Info-read-subfile
;; Note that on entry to this function the current-buffer must be the
;; *info* buffer; not the info tags buffer.
;; NODEPOS is either a position (in the Info file as a whole,
;; not relative to a subfile) or the name of a subfile.

;; Info-split-parameter-string
;; As of Texinfo 4.6, makeinfo writes constructs like
;;   \0\h[image param=value ...\h\0]
;; into the Info file for handling images.

;; Info-hide-cookies-node
;; Texinfo 4.7 adds cookies of the form ^@^H[NAME CONTENTS ^@^H].
;; Hide any construct of the general form ^@[^@-^_][ ...  ^@[^@-^_]],
;; including one optional trailing newline.

;; Info-read-node-name-1
;; This function is used as the "completion table" while reading a node name.
;; It does completion using the alist in Info-read-node-completion-table
;; unless STRING starts with an open-paren.

;; Info-following-node-name
;; For compatibility; other files have used this name.

;; Info-extract-menu-counting
;; If COUNT is nil, use the last item in the menu.

;;;;;;;;;;; src/xfaces.c ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Faces.
;;
;; When using Emacs with X, the display style of characters can be
;; changed by defining `faces'.  Each face can specify the following
;; display attributes:
;;
;; 1. Font family name.
;;
;; 2. Font foundary name.
;;
;; 3. Relative proportionate width, aka character set width or set
;; width (swidth), e.g. `semi-compressed'.
;;
;; 4. Font height in 1/10pt.
;;
;; 5. Font weight, e.g. `bold'.
;;
;; 6. Font slant, e.g. `italic'.
;;
;; 7. Foreground color.
;;
;; 8. Background color.
;;
;; 9. Whether or not characters should be underlined, and in what color.
;;
;; 10. Whether or not characters should be displayed in inverse video.
;;
;; 11. A background stipple, a bitmap.
;;
;; 12. Whether or not characters should be overlined, and in what color.
;;
;; 13. Whether or not characters should be strike-through, and in what
;; color.
;;
;; 14. Whether or not a box should be drawn around characters, the box
;; type, and, for simple boxes, in what color.
;;
;; 15. Font-spec, or nil.  This is a special attribute.
;;
;; A font-spec is a collection of font attributes (specs).
;;
;; When this attribute is specified, the face uses a font matching
;; with the specs as is except for what overwritten by the specs in
;; the fontset (see below).  In addition, the other font-related
;; attributes (1st thru 5th) are updated from the spec.
;;
;; On the other hand, if one of the other font-related attributes are
;; specified, the correspoinding specs in this attribute is set to nil.
;;
;; 15. A face name or list of face names from which to inherit attributes.
;;
;; 16. A specified average font width, which is invisible from Lisp,
;; and is used to ensure that a font specified on the command line,
;; for example, can be matched exactly.
;;
;; 17. A fontset name.  This is another special attribute.
;;
;; A fontset is a mappings from characters to font-specs, and the
;; specs overwrite the font-spec in the 14th attribute.
;;
;;
;; Faces are frame-local by nature because Emacs allows to define the
;; same named face (face names are symbols) differently for different
;; frames.  Each frame has an alist of face definitions for all named
;; faces.  The value of a named face in such an alist is a Lisp vector
;; with the symbol `face' in slot 0, and a slot for each of the face
;; attributes mentioned above.
;;
;; There is also a global face alist `Vface_new_frame_defaults'.  Face
;; definitions from this list are used to initialize faces of newly
;; created frames.
;;
;; A face doesn't have to specify all attributes.  Those not specified
;; have a value of `unspecified'.  Faces specifying all attributes but
;; the 14th are called `fully-specified'.
;;
;; Face merging.
;;
;; The display style of a given character in the text is determined by
;; combining several faces.  This process is called `face merging'.
;; Any aspect of the display style that isn't specified by overlays or
;; text properties is taken from the `default' face.  Since it is made
;; sure that the default face is always fully-specified, face merging
;; always results in a fully-specified face.
;;
;; Face realization.
;;
;; After all face attributes for a character have been determined by
;; merging faces of that character, that face is `realized'.  The
;; realization process maps face attributes to what is physically
;; available on the system where Emacs runs.  The result is a
;; `realized face' in form of a struct face which is stored in the
;; face cache of the frame on which it was realized.
;;
;; Face realization is done in the context of the character to display
;; because different fonts may be used for different characters.  In
;; other words, for characters that have different font
;; specifications, different realized faces are needed to display
;; them.
;;
;; Font specification is done by fontsets.  See the comment in
;; fontset.c for the details.  In the current implementation, all ASCII
;; characters share the same font in a fontset.
;;
;; Faces are at first realized for ASCII characters, and, at that
;; time, assigned a specific realized fontset.  Hereafter, we call
;; such a face as `ASCII face'.  When a face for a multibyte character
;; is realized, it inherits (thus shares) a fontset of an ASCII face
;; that has the same attributes other than font-related ones.
;;
;; Thus, all realized faces have a realized fontset.
;;
;; Unibyte text.
;;
;; Unibyte text (i.e. raw 8-bit characters) is displayed with the same
;; font as ASCII characters.  That is because it is expected that
;; unibyte text users specify a font that is suitable both for ASCII
;; and raw 8-bit characters.
;;
;; Font selection.
;;
;; Font selection tries to find the best available matching font for a
;; given (character, face) combination.
;;
;; If the face specifies a fontset name, that fontset determines a
;; pattern for fonts of the given character.  If the face specifies a
;; font name or the other font-related attributes, a fontset is
;; realized from the default fontset.  In that case, that
;; specification determines a pattern for ASCII characters and the
;; default fontset determines a pattern for multibyte characters.
;;
;; Available fonts on the system on which Emacs runs are then matched
;; against the font pattern.  The result of font selection is the best
;; match for the given face attributes in this font list.
;;
;; Font selection can be influenced by the user.
;;
;; 1. The user can specify the relative importance he gives the face
;; attributes width, height, weight, and slant by setting
;; face-font-selection-order (faces.el) to a list of face attribute
;; names.  The default is '(:width :height :weight :slant), and means
;; that font selection first tries to find a good match for the font
;; width specified by a face, then---within fonts with that
;; width---tries to find a best match for the specified font height,
;; etc.
;;
;; 2. Setting face-font-family-alternatives allows the user to
;; specify alternative font families to try if a family specified by a
;; face doesn't exist.
;;
;; 3. Setting face-font-registry-alternatives allows the user to
;; specify all alternative font registries to try for a face
;; specifying a registry.
;;
;; 4. Setting face-ignored-fonts allows the user to ignore specific
;; fonts.
;;
;; Character composition.
;;
;; Usually, the realization process is already finished when Emacs
;; actually reflects the desired glyph matrix on the screen.  However,
;; on displaying a composition (sequence of characters to be composed
;; on the screen), a suitable font for the components of the
;; composition is selected and realized while drawing them on the
;; screen, i.e.  the realization process is delayed but in principle
;; the same.
;;
;; Initialization of basic faces.
;;
;; The faces `default', `modeline' are considered `basic faces'.
;; When redisplay happens the first time for a newly created frame,
;; basic faces are realized for CHARSET_ASCII.  Frame parameters are
;; used to fill in unspecified attributes of the default face.  */


;;;;;;;;;;; lisp/ediff-mult.el ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; ediff-make-new-meta-list-element
;; Create a new element for the meta list out of obj1/2/3, which usually are
;; files
;;
;; The first nil in such an element is later replaced with the session buffer.
;; The second nil is reserved for session status.
;;
;; Also, session objects A/B/C are turned into lists of the form (obj nil).
;; This nil is a placeholder for eq-indicator. It is either nil or =.
;; If it is discovered that this file is = to some other
;; file in the same session, eq-indicator is changed to `='.
;; Currently, the eq-indicator is used only for 2 and 3-file jobs.

;; ediff-make-new-meta-list-header
;; Constructs a meta list header.
;; OBJA, OBJB, OBJC are usually directories involved, but can be different for
;; different jobs. For instance, multifile patch has only OBJA, which is the
;; patch buffer.

;; ediff-get-session-activity-marker
;; The activity marker is either or + (active session, i.e., ediff is currently
;; run in it), or - (finished session, i.e., we've ran ediff in it and then
;; exited).  Return nil, if session is neither active nor finished

;; ediff-meta-session-p
;; Wether the session-info is a meta session.

;; ediff-toggle-verbose-help-meta-buffer
;; Toggle verbose help in meta-buffers.

;; ediff-setup-meta-map
;; Set up the keymap in the meta buffer.

;; ediff-next-meta-item1
;; Move to the next meta item

;; ediff-intersect-directories
;; DIR1, DIR2, DIR3 are directories.  DIR3 can be nil.
;; OUTPUT-DIR is a directory for auto-storing the results of merge jobs.
;;	      Can be nil.
;; REGEXP is nil or a filter regexp; only file names that match the regexp
;; are considered.
;; If a file is a directory in dir1 but not dir2 (or vice versa), it is not
;; included in the intersection.  However, a regular file that is a dir in dir3
;; is included, since dir3 files are supposed to be ancestors for merging.
;; If COMPARISON-FUNC is given, use it.  Otherwise, use string=
;;
;; Returns a list of the form:
;;      (COMMON-PART DIFF-LIST)
;; COMMON-PART is car and DIFF-LIST is cdr.
;;
;; COMMON-PART is of the form:
;;	(META-HEADER (f1 f2 f3) (f1 f2 f3) ...)
;; f3 can be nil if intersecting only 2 directories.
;; Each triple (f1 f2 f3) represents the files to be compared in the
;; corresponding ediff subsession.
;;
;; DIFF-LIST is of the form:
;;	(META-HEADER (file . num) (file . num)...)
;; where num encodes the set of dirs where the file is found:
;; 2 - only dir1; 3 - only dir2; 5 - only dir3; 6 - dir1&2; 10 - dir1&3; etc.
;; META-HEADER:
;;       Contains the meta info about this ediff operation
;;       (regexp dir1 dir2 dir3 merge-auto-store-dir comparison-func)
;;       Later the meta-buffer is prepended to this list.
;;
;; Some operations might use a different meta header. For instance,
;; ediff-multifile-patch doesn't have dir2 and dir3, and regexp,
;; comparison-func don't apply.
;;

;; ediff-get-directory-files-under-revision
;; find directory files that are under revision.  Include subdirectories, since
;; we may visit them recursively.  DIR1 is the directory to inspect.
;; MERGE-AUTOSTORE-DIR is the directory where to auto-store the results of
;; merges.  Can be nil.

;; ediff-prepare-meta-buffer
;; Prepare meta-buffer in accordance with the argument-function and
;; redraw-function.  Must return the created  meta-buffer.

;; ediff-insert-session-activity-marker-in-meta-buffer
;; Insert the activity marker for session SESSION in the meta buffer at point
;; The activity marker is either SPC (untouched session), or + (active session,
;; i.e., ediff is currently run in it), or - (finished session, i.e., we've ran
;; ediff in it and then exited)

;; ediff-insert-session-status-in-meta-buffer
;; Insert session status at point.  Status is either ?H (marked for hiding), or
;; ?I (hidden or invalid), or ?* (meaning marked for an operation; currently,
;; such op can only be checking for equality)), or SPC (meaning neither marked
;; nor invalid)

;; ediff-replace-session-activity-marker-in-meta-buffer
;; If NEW-MARKER is non-nil, use it to substitute the current activity marker
;; in the meta buffer.  If nil, use SPC

;; ediff-replace-session-status-in-meta-buffer
;; If NEW-STATUS is non-nil, use it to substitute the current status marker in
;; the meta buffer.  If nil, use SPC

;; ediff-insert-session-info-in-meta-buffer
;; Insert all file info in meta buffer for a given session

;; ediff-redraw-directory-group-buffer 
;; extract directories from META-LIST.

;; ediff-problematic-session-p
;; Check if this SESSION is problematic.
;; Return nil if not.  Otherwise, return symbol representing the problem
;; At present, problematic sessions occur only in -with-ancestor comparisons
;; when the ancestor is a directory rather than a file, or when there is no
;; suitable ancestor file in the ancestor directory

;; ediff-fill-leading-zero
;; returns 2char string

;; ediff-format-date
;; TIME is like the output of decode-time

;; ediff-insert-dirs-in-meta-buffer
;; Draw the directories in META-LIST.

;; ediff-set-meta-overlay
;; Sets overlay around a meta record with 'ediff-meta-info property PROP
;; If optional SESSION-NUMBER, make it a property of the overlay,
;; ediff-meta-session-number
;; PROP is either the ctl or meta buffer (used when we work with the registry)
;; or a session meta descriptor of the form
;;                 (SESSION-CTL-BUFFER STATUS OBJA OBJB OBJC)

;; ediff-mark-session-for-hiding
;; Returns whether session was marked or unmarked

;; ediff-mark-session-for-operation
;; returns whether session was unmarked.
;; remember: this is a toggle op

;; ediff-operate-on-marked-sessions
;; Apply OPERATION to marked sessions.  Operation expects one argument of type
;; meta-list member (not the first one), i.e., a regular session description.
;; Returns number of marked sessions on which operation was performed

;; ediff-update-meta-buffer
;; If meta-buf doesn't exist, it is created.  In that case, id doesn't have a
;; parent meta-buf
;; Check if META-BUF exists before calling this function
;; Optional MUST-REDRAW, if non-nil, would force redrawal of the whole meta
;; buffer.  Otherwise, it will just go over the buffer and update activity marks
;; and session status.
;; SESSION-NUMBER, if specified, says which session caused the update.

;; ediff-cleanup-meta-buffer
;; If meta-buf exists, it is redrawn along with parent.
;; Otherwise, nothing happens.

;; ediff-safe-to-quit
;; Return non-nil if no session is in progress for META-BUFFER.

;; ediff-get-meta-info
;; Obtain information on a meta record where the user clicked or typed
;; BUF is the buffer where this happened and POINT is the position
;; If optional NOERROR arg is given, don't report error and return nil if no
;; meta info is found on line.

;; ediff-next-meta-overlay-start
;; Return location of the next meta overlay after point

;; ediff-patch-file-form-meta
;; this is the action invoked when the user selects a patch from the meta
;; buffer.

;; ediff-mark-if-equal
;; mark files 1 and 2 as equal, if they are.
;; returns t, if something was marked

;;; ==============================


;;; ==============================
;;; !!!UNFINISHED!!!!
(defun mon-help-doc-no-docd (undocd-sym w-doc f-or-v)
  "Add documentation to undocumented symbols.\n
:SEE-ALSO .\n►►►"
  (let ((f/v (and (or (eq f-or-v 'variable)
                      (eq f-or-v 'function)) 
                  f-or-v))
        do-doc)
    (case f/v
      (function 
       (or (documentation-property undocd-sym 'function-documentation)
           (get undocd-sym 'function-documentation))
    
       ))))
  ;; (documentation-property 'byte-compile-form 
  ;;                         (or (and f-or-v (eq f-or-v 'variable))

;;; ==============================  
;; NOTES for above incomplete-function:
;;; ==============================
;; (mon-help-doc-no-docd nil nil 'variable)
;; (mon-help-doc-no-docd 'mon-help-doc-no-docd nil 'function)
;;
;; (get 'mon-help-doc-no-docd 'function-documentation)
;; (documentation-property 'mon-help-doc-no-docd 'function-documentation)
;; (documentation 'mon-help-doc-no-docd)
;; (symbol-plist 'mon-help-doc-no-docd)
;;
;; (let* ((indf (indirect-function 
;;               ;;'mon-help-doc-no-docd)) ;;function
;;               'mon-foreach)) ;macro
;;               ;;'subrp)) ;;subr
;;               ;;'list-one-abbrev-table)) ;;autoload
;;        (csf-indf (car-safe indf)))
;;   (cond ((null csf-indf)
;;          (case (type-of indf)
;;            (subr "subr")
;;            (compiled-funcion "compiled-func")))
;;         ((eq csf-indf 'lambda)
;;          `("lambda" ,(cdr indf)))
;;         ((eq csf-indf 'macro)
;;          `("macro" ,(cdr indf)))
;;         ((eq csf-indf 'autoload) ;; <FUNCTION> <FILENAME> &optional <DOCSTRING>
;;          `("autoload" ,(cdr indf)))
;;         ))
;;
;;
;; (byte-code-function-p 
;;  (cdr ))
;; (indirect-function 'mon-foreach)
;;
;; (cdr (indirect-function 'mon-escape-string-for-cmd)
;;
;; (indirect-function 'mon-check-feature-for-loadtime)
;;
;;     
;; ;; compiled-function
;; #[ ( <ARG-LIST> ) 
;;      <BYTE-STR> 
;;    [ <CONSTANTS>* ]  
;;      <CONST-CNT-INT>  ;; :NOTE 0 indexed
;;      ( <PATHNAME-FILE> . <OFFSET>) ] 
;;
;; ;; compiled-macro
;; (macro . 
;;        #[ ( <ARG-LIST> ) 
;;             <BYTE-STR> 
;;           [ <CONSTANTS>* ]  
;;             <CONST-CNT-INT>  ;; :NOTE 0 indexed
;;           ( <PATHNAME-FILE> . <OFFSET>) ] )
;;
;; ;; subr 
;; #<subr `SYMBOL-NAME`>
;;
;; ;; interpreted function
;; (lambda ( <ARG-LIST> ) <DOCSTR> ( <FUNCTION-BODY> ))
;;
;; ;; interpreted macro
;; (macro lambda ( <ARG-LIST> ) <DOCSTR> ( <MACRO-BODY> ))
;;
;; ;; autoload  ;:NOTE <TYPE> <- 'macro | 'keymap
;; (autoload 
;;            <FILENAME> <DOCSTRING-OFFSET> <INTERACTIVE> <TYPE> )
;;
;;
;; ;; (type-of (indirect-function 'subrp))
;; (type-of (cadr (indirect-function 'mon-foreach)))
;;
;; (indirect-function 'file-cache-add-directory)
;;
;; (car-safe (indirect-function 'mon-list-merge))
;;
;; (byte-code-function-p (indirect-function 'subrp))
;; (lambda "lambda")
;;     (t "bubba")))
;;
;; (car-safe (indirect-function 'mon-help-doc-no-docd))
;;
;; (car-safe (indirect-function 'byte-compile-form))
;;
;; (type-of (indirect-function 'mon-list-merge))
;;
;;(indirect-function 'byte-compile-form)
;;; ==============================



;;; ==============================
(provide 'mon-doc-help-undocd)
;;; ==============================


;; Local Variables:
;; generated-autoload-file: "./mon-loaddefs.el"
;; no-byte-compile: t
;; End:

;;; ====================================================================
;;; mon-doc-help-undocd.el ends here
;;; EOF
